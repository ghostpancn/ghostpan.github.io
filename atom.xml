<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ghostpan&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ghostpan.com/"/>
  <updated>2018-05-09T04:14:13.858Z</updated>
  <id>http://blog.ghostpan.com/</id>
  
  <author>
    <name>Ghostpan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客迁移</title>
    <link href="http://blog.ghostpan.com/2018/05/08/start/"/>
    <id>http://blog.ghostpan.com/2018/05/08/start/</id>
    <published>2018-05-08T02:44:47.000Z</published>
    <updated>2018-05-09T04:14:13.858Z</updated>
    
    <content type="html"><![CDATA[<p>重新开始一个博客，改变生活态度换一种生活方式<br><a id="more"></a></p><h3 id="用-Hexo-作为博客框架"><a href="#用-Hexo-作为博客框架" class="headerlink" title="用 Hexo 作为博客框架"></a>用 Hexo 作为博客框架</h3><p>平时也有经常看一些其他人的博客，有在免费空间上的，也有用独立博客，果然还是比较喜欢独立博客，毕竟可以定制化嘛。</p><p>比较喜欢简洁的风格，所以选用了 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>(<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">apollo</a> 主题) 作为博客框架。</p><h3 id="博客记录的内容"><a href="#博客记录的内容" class="headerlink" title="博客记录的内容"></a>博客记录的内容</h3><p>陆续整理之前的博客，在新博客上展示</p><p>分享记录以后工作中学习中遇到的问题和解决方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新开始一个博客，改变生活态度换一种生活方式&lt;br&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://blog.ghostpan.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 修改新建文件中文件注释里的信息</title>
    <link href="http://blog.ghostpan.com/2017/10/25/customize-text-macros/"/>
    <id>http://blog.ghostpan.com/2017/10/25/customize-text-macros/</id>
    <published>2017-10-25T10:04:52.000Z</published>
    <updated>2018-05-15T07:02:59.169Z</updated>
    
    <content type="html"><![CDATA[<p>最近用别人电脑写程序的时候发现用 Xcode 新建文件的文件注释中 Created by 是其他人的名字！！！！明显文件注释中的 Created by 默认取得当前电脑用户的用户名。</p><p>查阅了一下网上修改 Created by 的方法发现都不太合适，翻阅 Xcode Help 找到了想要的方法。<br><a id="more"></a></p><h3 id="网络上常见的修改方法"><a href="#网络上常见的修改方法" class="headerlink" title="网络上常见的修改方法"></a>网络上常见的修改方法</h3><p>常见的修改方法有大概这两种：</p><ol><li>在 Xcode 安装包中修改官方模板文件</li><li>设置当前电脑用户的用户名</li></ol><h3 id="Xcode-官方提供的修改方法"><a href="#Xcode-官方提供的修改方法" class="headerlink" title="Xcode 官方提供的修改方法"></a>Xcode 官方提供的修改方法</h3><p>在 Xcode Help 中看到了 <a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev91a7a31fc" target="_blank" rel="noopener">Customize text macros</a> 里面提到只需要在合适的地方添加一个 <code>IDETemplateMacros.plist</code> 文件就可以解决在不同的情况下使用不同的文件注释，优先级递减：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Project user data: &lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure><p>仅仅对单个 Project 且单个用户有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Project shared data: &lt;ProjectName&gt;.xcodeproj/xcshareddata/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure><p>对单个 Project 的所有用户有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Workspace user data: &lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure><p>对单个 Workspace 且单个用户有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Workspace shared data: &lt;WorkspaceName&gt;.xcworkspace/xcshareddata/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure><p>对单个 Workspace 的所有用户有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User Xcode data: ~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist</span><br></pre></td></tr></table></figure><p>对单个用户的所有新建文件有效。</p><h3 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h3><p>Xcode 提供了多个可用于自定义的属性，下面列举几个常用的属性：</p><ol><li>FILEHEADER，替换新建文件的所有文件注释</li><li>FULLUSERNAME，替换 Created by 作者</li><li>NSHUMANREADABLECOPYRIGHTPLIST，版权申明</li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>相对于网络上普遍采用的方法，Xcode 提供的方法更加的灵活简单。<br>很多人喜欢给自己的电脑用户名起一个比较炫的名字，但是团队项目中很容易穿插各种奇奇怪怪的名字，乱而不规范。采用 Xcode 提供的方式去让项目变得更规范更整洁吧。</p><h3 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h3><p><a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/dev91a7a31fc" target="_blank" rel="noopener">Customize text macros</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用别人电脑写程序的时候发现用 Xcode 新建文件的文件注释中 Created by 是其他人的名字！！！！明显文件注释中的 Created by 默认取得当前电脑用户的用户名。&lt;/p&gt;
&lt;p&gt;查阅了一下网上修改 Created by 的方法发现都不太合适，翻阅 Xcode Help 找到了想要的方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.ghostpan.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://blog.ghostpan.com/tags/Xcode/"/>
    
      <category term="小技巧" scheme="http://blog.ghostpan.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 初识（三）</title>
    <link href="http://blog.ghostpan.com/2016/04/03/runtime-3/"/>
    <id>http://blog.ghostpan.com/2016/04/03/runtime-3/</id>
    <published>2016-04-03T05:43:33.000Z</published>
    <updated>2018-05-17T10:14:51.552Z</updated>
    
    <content type="html"><![CDATA[<p>学习完 Runtime 的基本知识，接下来看一下 Runtime 在实际开发中的一些应用场景。</p><a id="more"></a><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>Runtime 中最常用的一个功能了吧，在运行时将两个 Method 替换，利用这个特性可以在 OC 开发中实现 AOP。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(_my_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_my_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> _my_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %s"</span>, <span class="keyword">self</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ul><li>Swizzling 应该在 <code>+ (void)load</code> 中执行，相比较于 <code>+ (void)initialize</code> ，前者能保证在类初始加载时调用，而后者是懒加载的调用方式，只有第一次对类发送消息才会调用。</li><li><code>+ (void)load</code> 方法中不应该调用 <code>[super load]</code> 。</li><li>Swizzling 应该在 <code>dispatch_once</code> 中执行，保证不管有多少线程都只被执行一次。</li><li>需要先判断被替换的方法有没有被当前类实现还是被当前类的父类实现的。</li></ul><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO 的本质就是替换了对象的 isa 指向，将对象的 isa 指向了动态创建的一个子类上，之后对象调用对象方法实质上是去查找这个动态创建的子类的方法列表，利用这一点 KVO 重写了需要实现监听属性的 set 方法，在 set 方法前后添加了下面的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure><h3 id="Associated-Object"><a href="#Associated-Object" class="headerlink" title="Associated Object"></a>Associated Object</h3><p>开发中经常用到分类，应该都遇到过需要给分类添加一个属性，但是正常情况下 OC 不允许在分类中添加成员变量，所以即使在分类中添加了 <code>@property</code> 也并不会正常的生成存取方法和成员变量，只能手动的去给它实现存取方法，并给它关联一个对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> associcatedObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)associcatedObject &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAssocicatedObject:(<span class="keyword">id</span>)associcatedObject &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associcatedObject), associcatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>代码中用到了 <code>_cmd</code> 和 <code>@selector(associcatedObject)</code> 作为关联对象的 key ，其中 <code>_cmd</code> 是方法的隐藏参数，和 <code>@selector(associcatedObject)</code> 一样都是一个 SEL 类型，获取的是一个 C 语言字符串，所以用在这里可以更加简洁。</p><p><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 是关联对象的存储策略，相当于 <code>@property(nonatomic, strong)</code> 。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Runtime 还有很多应用场景，需要学习的知识也很多，这次初步了解记录了目前能理解的，在今后知识面扩充之后有时间应该会再识 Runtime。</p><h3 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h3><ul><li><a href="https://ming1016.github.io/2015/04/01/objc-runtime/" target="_blank" rel="noopener">Objc Runtime 总结</a></li><li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习完 Runtime 的基本知识，接下来看一下 Runtime 在实际开发中的一些应用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Runtime" scheme="http://blog.ghostpan.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 初识（二）</title>
    <link href="http://blog.ghostpan.com/2016/02/24/runtime-2/"/>
    <id>http://blog.ghostpan.com/2016/02/24/runtime-2/</id>
    <published>2016-02-24T02:22:15.000Z</published>
    <updated>2018-05-16T10:49:36.725Z</updated>
    
    <content type="html"><![CDATA[<p>前面了解了类的基本布局，这次来了解一下 OC 中的消息处理，之前也知道 OC 上所有方法的调用实际上都是 <code>objc_msgSend</code> 函数的调用，但是具体怎么调用的没有深入了解，这次来学习学习。</p><a id="more"></a><h3 id="消息中用到的数据类型"><a href="#消息中用到的数据类型" class="headerlink" title="消息中用到的数据类型"></a>消息中用到的数据类型</h3><h6 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h6><p>类中的方法类型，是一个 <code>objc_method</code> 结构体指针：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">     SEL method_name OBJC2_UNAVAILABLE;</span><br><span class="line">     <span class="keyword">char</span> *method_types OBJC2_UNAVAILABLE;</span><br><span class="line">     IMP method_imp OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h6><p>方法的方法名，是一个 <code>objc_selector</code> 结构体指针：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure><p><code>objc_selector</code> 结构体不透明，但是可以理解成一个 C 语言的字符串，运行时中维护了一张 SEL 的表，它把相同名字的方法名映射到了一个唯一的 SEL 上，不同的类中如果方法名相同他们的 SEL 也是相同的，同一个类中不能有两个相同的 SEL ，也就是 OC 不能支持重载。</p><p>SEL 的三种获取方式：</p><ul><li>sel_registerName(char *name)</li><li>NSSelectorFromString(NSString *aSelectorName) </li><li>@selector(selector) </li></ul><h6 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h6><p>函数指针，OC 中的方法最终都会被转化为 C 语言的函数，IMP 就是指向这些函数首地址的指针。可以通过 <code>method_getImplementation</code> 获取 IMP 之后直接进行函数调用跳过 OC 的消息发送过程。</p><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>OC 中的方法调用 [object method] ，编译器会将它转化为下面的函数调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ...);</span><br></pre></td></tr></table></figure><p>这个函数有两个默认参数：</p><ul><li>self 就是消息的发送者，这也是为什么我们在方法中可以直接调用 self 的原因，对象方法中 self 是对象，类方法中 self 就是类对象了。</li><li>_cmd 是 <code>SEL</code> 类型的，当前方法的选择器，消息发送过程中会通过它查找 IMP ，最后做函数调用。</li></ul><p><code>obj_msgSend</code> 是用汇编实现的，借用 <a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/5/" target="_blank" rel="noopener">伪代码</a> 加深一下理解：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">IMP imp = class_getMethodImplementation(<span class="keyword">self</span>-&gt;isa, SEL op);</span><br><span class="line">imp(<span class="keyword">self</span>, op, ...); <span class="comment">//调用这个函数，伪代码...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查找IMP</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls || !sel) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (!imp) <span class="keyword">return</span> _objc_msgForward; <span class="comment">//这个是用于消息转发的</span></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;initialize()) &#123;</span><br><span class="line">        _class_initialize(cls);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Class curClass = cls;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">//先查缓存,缓存没有时重建,仍旧没有则向父类查询</span></span><br><span class="line">        <span class="keyword">if</span> (!curClass) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!curClass-&gt;cache) fill_cache(cls, curClass);</span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (curClass = curClass-&gt;superclass);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到伪代码就很容易理解 <code>obj_msgSend</code> 所做的事了：</p><ol><li>先判断消息的调用对象是否存在，不存在就直接返回，所以可以像 nil 发送任意消息而不会有什么副作用</li><li>对象的 isa 中查找 IMP，即如果是对象就在它的类对象的方法列表中查找，如果是类对象就在它的元类对象的方法列表中查找。查找 IMP 的过程如下：<ol><li>判断这个类对象和选择子是否存在，不存在就直接返回 nil</li><li>先查找这个类对象的方法缓存列表，如果缓存列表中没有，去这个类对象的方法列表中查找，如果依旧找到就递归它的父类继续查找</li><li>如果没有找到 IMP 就返回一个消息转发函数 <code>_objc_msgForward</code></li><li>返回这个最终的 IMP</li></ol></li><li>调用这个 IMP，如果正常在这个对象的类对象中查找到了 IMP ，那么这个消息发送就完成了，如果返回的是 <code>_objc_msgForward</code> 就要开始消息转发流程了</li></ol><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>给一个对象发送消息时，如果这个对象无法响应这个方法，即它的类对象中找不到相应的 IMP ，最后返回了 <code>_objc_msgForward</code> 开始进入消息转发，消息转发主要有三个阶段。</p><h6 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h6><p>可以重写下面两个方法分别对类方法和对象方法做动态方法解析：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure><p>允许用户在这里动态的添加方法实现，如果实现了，调用并返回，如果没有实现就继续下一个阶段。</p><h6 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h6><p>这一阶段中，Runtime 会通过下面的方法询问是否能将这个消息转发给其他的接收者：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>如果这里返回了一个备援接收者，就开始新的消息发送过程，如果没有备援接收者就进入完整的消息转发流程。</p><p>在这个阶段就可以实现 OC 的多重继承了。</p><h6 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h6><p>在这个阶段，Runtime 会先调用 <code>methodSignatureForSelector:</code> 方法获取方法签名，如果获取不到方法签名就抛出异常。</p><p>将获取到的方法签名转换为一个 <code>NSInvocation</code> 的对象传入下面的方法中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure><p>在这个方法中就可以调用其他对象的其他方法开始完整的消息转发了。</p><h3 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h3><ul><li><a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/5/" target="_blank" rel="noopener">Objective-C 中的消息与消息转发</a></li><li><a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="noopener">Objective-C Runtime 运行时之三：方法与消息</a></li><li><a href="https://ming1016.github.io/2015/04/01/objc-runtime/" target="_blank" rel="noopener">Objc Runtime 总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面了解了类的基本布局，这次来了解一下 OC 中的消息处理，之前也知道 OC 上所有方法的调用实际上都是 &lt;code&gt;objc_msgSend&lt;/code&gt; 函数的调用，但是具体怎么调用的没有深入了解，这次来学习学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Runtime" scheme="http://blog.ghostpan.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 初识（一）</title>
    <link href="http://blog.ghostpan.com/2016/02/04/runtime-1/"/>
    <id>http://blog.ghostpan.com/2016/02/04/runtime-1/</id>
    <published>2016-02-04T08:08:05.000Z</published>
    <updated>2018-05-16T06:03:12.011Z</updated>
    
    <content type="html"><![CDATA[<p>平时也有了解一些 Runtime 相关的知识，但都是只处于知道阶段没有详细了解过，最近没有那么忙了准备抽个时间来边学边记录一下。</p><a id="more"></a><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><p>Runtime 字面意思运行时，是一个将 C 语言转化为面向对象语言的扩展，是 Objective-C 被称之为动态语言的核心。</p><p>在 C 语言中函数的调用在编译期就已经确定，而在 Objective-C 中在编译期内无法确定具体调用哪个函数，只有在真正运行的时候才确定调用。</p><p>本篇博客具体记录基于 objc2.0 对象在 Runtime 中的定义。</p><h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><p>objc2.0 之后的 objc_class 定义如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以得出：</p><ul><li>Objective-C 的对象都是 C 语言结构体</li><li><code>id</code> 是指向 <code>struct objc_object</code> 的一个指针</li><li><code>class</code> 是指向 <code>objc_class</code> 的指针</li><li><code>objc_class</code> 继承于 `objc_object</li></ul><h3 id="isa-amp-superclass"><a href="#isa-amp-superclass" class="headerlink" title="isa &amp; superclass"></a>isa &amp; superclass</h3><p>isa 是一个 <code>isa_t</code> 的结构体，它包含了当前对象指向的类的信息。</p><ul><li>对象中的 isa 指向它的类对象</li><li>类对象中的 isa 指向它的元类对象</li></ul><p>superclass 指向它的父类对象。</p><p>对应关系图如下：</p><p><img src="/images/class diagram.png" alt="class diagram"></p><p>类对象的 isa 指向一个 <code>meta class</code> 元类，所有元类的 isa 都指向了 <code>Root class (meta)</code> ，而 <code>Root class (meta)</code> 是 <code>Root class (class)</code> 的子类，即 NSObject / NSProxy 的子类。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>cache 用于方法性能优化，每次发送消息时，优先在 cache 中查找，查找不到的情况下去类和它的父类方法列表中查找，找不到的情况下消息转发，找到之后会将方法缓存在 cache 中。</p><p>找到 cache_t 结构体的具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;  </span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint32_t;  </span><br><span class="line"><span class="keyword">typedef</span> uint32_t mask_t;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  uintptr_t;  </span><br><span class="line"><span class="keyword">typedef</span> uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;  </span><br><span class="line">private:  </span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>_buckets 是一个散列表，用来做方法缓存</li><li>_mask 分配可以缓存的 <code>bucket_t</code> 总数</li><li>_occupied 实际占用缓存的 <code>bucket_t</code> 个数</li></ul><h3 id="bits"><a href="#bits" class="headerlink" title="bits"></a>bits</h3><p><code>class_data_bits_t</code> 源码实现如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;  </span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;  </span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>class_rw_t</code> 中存放类的属性列表、方法列表、遵循的协议列表、只读的 <code>class_ro_t</code> 等，它提供了运行时对类进行扩展的能力。</p><p><code>class_ro_t</code> 存储的信息基本都是编译时就已经可以确定的信息，在编译之后不做修改。</p><p>类初始化之前 <code>objc_class-&gt;data()</code> 返回的指针指向的是一个 <code>class_ro_t</code> 结构体，初始化时类调用 <code>realizeClass</code> 静态方法，开辟一个 <code>class_rw_t</code> 的空间，并把 <code>class_ro_t</code> 指针赋值给 <code>class_rw_t-&gt;ro</code> ，具体实现细节有时间在仔细研究研究。。</p><h3 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h3><ul><li><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li><li><a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">Objective-C Runtime 运行时之一：类与对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时也有了解一些 Runtime 相关的知识，但都是只处于知道阶段没有详细了解过，最近没有那么忙了准备抽个时间来边学边记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Runtime" scheme="http://blog.ghostpan.com/tags/Runtime/"/>
    
  </entry>
  
</feed>
